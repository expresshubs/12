getgenv().SilentAimSettings = {
    Enabled = false,
    TeamCheck = false,
    VisibleCheck = false, 
    TargetPart = "Head",
    SilentAimMethod = "FindPartOnRay",
    FOVRadius = 130,
    FOVVisible = false,
    FOVColor = Color3.fromRGB(255, 0, 255),
    ShowSnapLine = false, 
    Snaplinecolor = Color3.fromRGB(255, 0, 255),
    MouseHitPrediction = false,
    MouseHitPredictionAmount = 0.165,
    HitChance = 100,
    IgnoreFriends = false,
    FOVMode = "Cursor",
    RaycastWallbang = false
}
local next = next
local pcall = pcall
local Vector2New = Vector2.new
local Color3FromRGB = Color3.fromRGB
local RayNew = Ray.new
local mathFloor = math.floor
local mathRandom = math.random
local tableUnpack = unpack or table.unpack 
Camera = workspace.CurrentCamera
Players = game:GetService("Players")
RunService = game:GetService("RunService")
UserInputService = game:GetService("UserInputService")
LocalPlayer = Players.LocalPlayer
Mouse = LocalPlayer:GetMouse()
GetChildren = game.GetChildren
GetPlayers = Players.GetPlayers
WorldToScreen = Camera.WorldToScreenPoint
WorldToViewportPoint = Camera.WorldToViewportPoint
GetPartsObscuringTarget = Camera.GetPartsObscuringTarget
FindFirstChild = game.FindFirstChild
RenderStepped = RunService.RenderStepped
GetMouseLocation = UserInputService.GetMouseLocation
ValidTargetParts = {"Head", "HumanoidRootPart"}
PredictionAmount = 0.165

local fov_circle = Drawing.new("Circle")
fov_circle.Thickness = 1
fov_circle.NumSides = 100
fov_circle.Radius = getgenv().SilentAimSettings.FOVRadius
fov_circle.Filled = false
fov_circle.Visible = getgenv().SilentAimSettings.FOVVisible
fov_circle.ZIndex = 999
fov_circle.Transparency = 1
fov_circle.Color = getgenv().SilentAimSettings.FOVColor

local snap_line = Drawing.new("Line")
snap_line.Visible = getgenv().SilentAimSettings.ShowSnapLine
snap_line.ZIndex = 999 
snap_line.Color = getgenv().SilentAimSettings.Snaplinecolor
snap_line.Thickness = 1

local ExpectedArguments = {
    FindPartOnRayWithIgnoreList = {
        ArgCountRequired = 3,
        Args = {
            "Instance", "Ray", "table", "boolean", "boolean"
        }
    },
    FindPartOnRayWithWhitelist = {
        ArgCountRequired = 3,
        Args = {
            "Instance", "Ray", "table", "boolean"
        }
    },
    FindPartOnRay = {
        ArgCountRequired = 2,
        Args = {
            "Instance", "Ray", "Instance", "boolean", "boolean"
        }
    },
    Raycast = {
        ArgCountRequired = 3,
        Args = {
            "Instance", "Vector3", "Vector3", "RaycastParams"
        }
    }
}

function CalculateChance(Percentage)
    Percentage = math.floor(Percentage)
    local chance = math.floor(Random.new().NextNumber(Random.new(), 0, 1) * 100) / 100
    return chance <= Percentage / 100
end

local function getPositionOnScreen(Vector)
    local Vec3, OnScreen = WorldToScreen(Camera, Vector)
    return Vector2.new(Vec3.X, Vec3.Y), OnScreen
end

local function ValidateArguments(Args, RayMethod)
    local Matches = 0
    if #Args < RayMethod.ArgCountRequired then
        return false
    end
    for Pos, Argument in next, Args do
        if typeof(Argument) == RayMethod.Args[Pos] then
            Matches = Matches + 1
        end
    end
    return Matches >= RayMethod.ArgCountRequired
end

local function getDirection(Origin, Position)
    return (Position - Origin).Unit * 1000
end

local function getMousePosition()
    return GetMouseLocation(UserInputService)
end

local function IsPlayerVisible(Player)
    local PlayerCharacter = Player.Character
    local LocalPlayerCharacter = LocalPlayer.Character
    
    if not (PlayerCharacter or LocalPlayerCharacter) then return end 
    
    local PlayerRoot = FindFirstChild(PlayerCharacter, SilentAimSettings.TargetPart) or FindFirstChild(PlayerCharacter, "HumanoidRootPart")
    
    if not PlayerRoot then return end 
    
    local CastPoints, IgnoreList = {PlayerRoot.Position, LocalPlayerCharacter, PlayerCharacter}, {LocalPlayerCharacter, PlayerCharacter}
    local ObscuringObjects = #GetPartsObscuringTarget(Camera, CastPoints, IgnoreList)
    
    return ((ObscuringObjects == 0 and true) or (ObscuringObjects > 0 and false))
end
function getClosestPlayer()
    if not SilentAimSettings.TargetPart then return nil end
    
    local Closest = nil
    local DistanceToMouse = nil
    local CurrentMousePos = getMousePosition()
    local fovMode = getgenv().SilentAimSettings.FOVMode
    if fovMode == "Middle" then
        CurrentMousePos = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    end
    local FOVRadius = getgenv().SilentAimSettings.FOVRadius or 2000
    local TeamCheck = getgenv().SilentAimSettings.TeamCheck
    local VisibleCheck = getgenv().SilentAimSettings.VisibleCheck
    local TargetPart = getgenv().SilentAimSettings.TargetPart
    
    for _, Player in next, GetPlayers(Players) do
        if Player == LocalPlayer then continue end
        if TeamCheck and Player.Team == LocalPlayer.Team then continue end
        if getgenv().SilentAimSettings.IgnoreFriends then
            local success, isFriend = pcall(function()
                return LocalPlayer:IsFriendsWith(Player.UserId)
            end)
            if success and isFriend then continue end
        end

        local Character = Player.Character
        if not Character then continue end
        
        if VisibleCheck and not IsPlayerVisible(Player) then continue end

        local HumanoidRootPart = FindFirstChild(Character, "HumanoidRootPart")
        local Humanoid = FindFirstChild(Character, "Humanoid")
        
        if not HumanoidRootPart or not Humanoid then continue end
        if Humanoid.Health <= 0 then continue end

        local ScreenPosition, OnScreen = getPositionOnScreen(HumanoidRootPart.Position)
        if not OnScreen then continue end

        local Distance = (CurrentMousePos - ScreenPosition).Magnitude
        if Distance <= (DistanceToMouse or FOVRadius) then
            if TargetPart == "Random" then
                local randomIndex = mathRandom(1, #ValidTargetParts)
                local partName = ValidTargetParts[randomIndex]
                Closest = Character[partName]
            else
                Closest = Character[TargetPart]
                if not Closest then
                    Closest = HumanoidRootPart
                end
            end
            DistanceToMouse = Distance
        end
    end
    return Closest
end
local lastUpdate = tick()
local updateInterval = 0.01
local cachedMousePos = getMousePosition()
RunService.RenderStepped:Connect(function(deltaTime)
    local currentTime = tick()
    if currentTime - lastUpdate < updateInterval then return end
    lastUpdate = currentTime
    cachedMousePos = getMousePosition()
    local settings = getgenv().SilentAimSettings
    local fovMode = settings.FOVMode
    if fovMode == "Middle" then
        fov_circle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    else
        fov_circle.Position = cachedMousePos
    end
    fov_circle.Radius = settings.FOVRadius
    fov_circle.Visible = settings.FOVVisible
    fov_circle.Color = settings.FOVColor
    if settings.ShowSnapLine and settings.Enabled then
        local Target = getClosestPlayer()
        if Target then
            local Root = Target.Parent.PrimaryPart or Target
            local _, IsOnScreen = nil, false
            pcall(function()
                local RootToViewportPoint
                RootToViewportPoint, IsOnScreen = WorldToViewportPoint(Camera, Root.Position)
                if IsOnScreen then
                    local fovMode = settings.FOVMode
                    if fovMode == "Middle" then
                        local lpChar = LocalPlayer and LocalPlayer.Character
                        local lpHead = lpChar and (lpChar:FindFirstChild("Head") or lpChar:FindFirstChild("HumanoidRootPart"))
                        if lpHead then
                            local lpHeadScreen, lpHeadOnScreen = WorldToViewportPoint(Camera, lpHead.Position)
                            if lpHeadOnScreen then
                                snap_line.From = Vector2.new(lpHeadScreen.X, lpHeadScreen.Y)
                                snap_line.To = Vector2.new(RootToViewportPoint.X, RootToViewportPoint.Y)
                            else
                                snap_line.From = Vector2.new(RootToViewportPoint.X, RootToViewportPoint.Y)
                                snap_line.To = Vector2.new(RootToViewportPoint.X, RootToViewportPoint.Y)
                            end
                        else
                            snap_line.From = Vector2.new(RootToViewportPoint.X, RootToViewportPoint.Y)
                            snap_line.To = Vector2.new(RootToViewportPoint.X, RootToViewportPoint.Y)
                        end
                    else
                        snap_line.From = Vector2.new(cachedMousePos.X, cachedMousePos.Y)
                        snap_line.To = Vector2.new(RootToViewportPoint.X, RootToViewportPoint.Y)
                    end
                end
                snap_line.Color = settings.Snaplinecolor
                snap_line.Visible = IsOnScreen
            end)
        else
            snap_line.Visible = false
        end
    else
        snap_line.Visible = false
    end
end)


local oldNamecall
oldNamecall = hookmetamethod(game, "__namecall", newcclosure(function(...)
    local Method = getnamecallmethod()
    local Arguments = {...}
    local self = Arguments[1]
    local settings = getgenv().SilentAimSettings
    local chance = CalculateChance(settings.HitChance)
    if settings.Enabled and self == workspace and not checkcaller() and chance == true then
        if Method == "FindPartOnRayWithIgnoreList" and settings.SilentAimMethod == Method then
            if ValidateArguments(Arguments, ExpectedArguments.FindPartOnRayWithIgnoreList) then
                local A_Ray = Arguments[2]
                local HitPart = getClosestPlayer()
                if HitPart then
                    local Origin = A_Ray.Origin
                    local Direction = getDirection(Origin, HitPart.Position)
                    Arguments[2] = Ray.new(Origin, Direction)
                    return oldNamecall(unpack(Arguments))
                end
            end
        elseif Method == "FindPartOnRayWithWhitelist" and settings.SilentAimMethod == Method then
            if ValidateArguments(Arguments, ExpectedArguments.FindPartOnRayWithWhitelist) then
                local A_Ray = Arguments[2]
                local HitPart = getClosestPlayer()
                if HitPart then
                    local Origin = A_Ray.Origin
                    local Direction = getDirection(Origin, HitPart.Position)
                    Arguments[2] = Ray.new(Origin, Direction)
                    return oldNamecall(unpack(Arguments))
                end
            end
        elseif (Method == "FindPartOnRay" or Method == "findPartOnRay") and settings.SilentAimMethod:lower() == Method:lower() then
            if ValidateArguments(Arguments, ExpectedArguments.FindPartOnRay) then
                local A_Ray = Arguments[2]
                local HitPart = getClosestPlayer()
                if HitPart then
                    local Origin = A_Ray.Origin
                    local Direction = getDirection(Origin, HitPart.Position)
                    Arguments[2] = Ray.new(Origin, Direction)
                    return oldNamecall(unpack(Arguments))
                end
            end
        elseif Method == "Raycast" then
            local EA = ExpectedArguments
            if ValidateArguments(Arguments, EA.Raycast) then
                local A_Origin = Arguments[2]
                local HitPart = getClosestPlayer()
                if HitPart then
                    Arguments[3] = getDirection(A_Origin, HitPart.Position)
                    if settings.RaycastWallbang then
                        if not lastWallbangTime then lastWallbangTime = 0 end
                        if not wallbangCooldown then wallbangCooldown = 0.2 end
                        if tick() - lastWallbangTime > wallbangCooldown then
                            lastWallbangTime = tick()
                            local params = RaycastParams.new()
                            params.FilterType = Enum.RaycastFilterType.Include
                            params.IgnoreWater = true
                            params.RespectCanCollide = false
                            if typeof(GetWallbangableTable) == "function" then
                                params.FilterDescendantsInstances = GetWallbangableTable(HitPart)
                            else
                                params.FilterDescendantsInstances = {HitPart}
                            end
                            Arguments[4] = params
                        end
                    end
                    return oldNamecall(unpack(Arguments))
                end
            end
        end
    end
    return oldNamecall(...)
end))


local oldIndex = nil 
oldIndex = hookmetamethod(game, "__index", newcclosure(function(self, Index)
    local settings = getgenv().SilentAimSettings
    if self == Mouse and not checkcaller() and settings.Enabled and settings.SilentAimMethod == "Mouse.Hit/Target" and getClosestPlayer() then
        local HitPart = getClosestPlayer()
        if Index == "Target" or Index == "target" then 
            return HitPart
        elseif Index == "Hit" or Index == "hit" then 
            return ((settings.MouseHitPrediction and (HitPart.CFrame + (HitPart.Velocity * PredictionAmount))) or (not settings.MouseHitPrediction and HitPart.CFrame))
        elseif Index == "X" or Index == "x" then 
            return self.X 
        elseif Index == "Y" or Index == "y" then 
            return self.Y 
        elseif Index == "UnitRay" then 
            return Ray.new(self.Origin, (self.Hit - self.Origin).Unit)
        end
    end
    return oldIndex(self, Index)
end))

